{
  "CONFIGURATION_MIGRATION.html": {
    "href": "CONFIGURATION_MIGRATION.html",
    "title": "Configuration Migration Summary | Metro Fare Calculator API Documentation",
    "summary": "Configuration Migration Summary Overview Successfully migrated all hardcoded constants from the Metro Fare Calculator application to a configuration-based system using appsettings.json and strongly-typed configuration classes. ✅ What Was Moved to Configuration 1. Fare Calculation Settings Before: Hardcoded in individual service classes After: Centralized in appsettings.json under FareCalculation section Zone-based fare amounts (1 zone: $2.50, 2 zones: $3.75, 3 zones: $5.00) Distance-based fare settings (base: $1.50, rate: $0.25/km) Passenger discount percentages (Child/Disabled: 50%, Senior: 30%, Student: 20%, Adult: 0%) Time-based pricing rules (peak surcharge: 25%, off-peak discount: 10%) Peak hour definitions (7-9 AM, 5-7 PM weekdays) Off-peak hour definitions (10 PM - 6 AM) Zone mapping (A=1, B=2, C=3) Strategy priorities (Zone-based: 100, Distance-based: 50, etc.) 2. Station Data Before: Hardcoded in StationService.InitializeStations() After: Loaded from appsettings.json under Stations section 8 metro stations with coordinates, zones, and names Latitude/longitude for distance calculations Zone assignments for fare calculations 3. Geography Constants Before: Hardcoded const double R = 6371 in StationService After: Configurable in Geography.EarthRadiusKilometers Earth radius for Haversine distance calculations \uD83C\uDFD7️ Architecture Changes New Configuration Classes Created strongly-typed configuration classes in src/FareCalculator/Configuration/: FareCalculationOptions - Main fare calculation settings DistanceBasedFareOptions - Distance calculation parameters TimeBasedRulesOptions - Time-based pricing rules PeakHourOptions - Peak hour configuration OffPeakHourOptions - Off-peak hour configuration StrategyPriorityOptions - Strategy pattern priorities GeographyOptions - Geographical calculation constants StationOptions - Station data configuration Updated Services Modified all services to use dependency injection for configuration: ZoneBasedFareStrategy - Uses IOptions<FareCalculationOptions> DistanceBasedFareStrategy - Uses IOptions<FareCalculationOptions> PassengerDiscountStrategy - Uses IOptions<FareCalculationOptions> TimeBasedDiscountStrategy - Uses IOptions<FareCalculationOptions> FareRuleEngine - Uses IOptions<FareCalculationOptions> StationService - Uses IOptions<List<Station>> and IOptions<GeographyOptions> Configuration Registration Updated Program.cs to register all configuration sections: services.Configure<FareCalculationOptions>( context.Configuration.GetSection(FareCalculationOptions.SectionName)); services.Configure<GeographyOptions>( context.Configuration.GetSection(GeographyOptions.SectionName)); services.Configure<List<Station>>( context.Configuration.GetSection(StationOptions.SectionName)); \uD83D\uDCC1 File Changes New Files src/FareCalculator/Configuration/FareCalculationConfig.cs - Configuration classes src/FareCalculator/appsettings.json - Configuration data CONFIGURATION_MIGRATION.md - This summary document Modified Files src/FareCalculator/FareCalculator.csproj - Added configuration packages src/FareCalculator/Program.cs - Configuration registration src/FareCalculator/Services/FareRuleEngine.cs - Configuration injection src/FareCalculator/Services/StationService.cs - Configuration injection src/FareCalculator/Strategies/*.cs - All strategies updated tests/**/*.cs - All test files updated with configuration mocks README.md - Updated with configuration documentation \uD83D\uDD27 Configuration Structure The appsettings.json is organized into logical sections: { \"Logging\": { /* Standard .NET logging config */ }, \"FareCalculation\": { \"Currency\": \"USD\", \"ZoneBasedFares\": { /* Zone pricing */ }, \"DistanceBasedFares\": { /* Distance pricing */ }, \"PassengerDiscounts\": { /* Discount percentages */ }, \"TimeBasedRules\": { /* Peak/off-peak rules */ }, \"ZoneMapping\": { /* Zone letter to number mapping */ }, \"Priorities\": { /* Strategy execution priorities */ } }, \"Geography\": { \"EarthRadiusKilometers\": 6371 }, \"Stations\": [ /* Array of station objects */ ] } ✅ Benefits Achieved 1. Maintainability No code recompilation needed for fare changes Easy to modify pricing rules seasonally Simple station data management 2. Flexibility Environment-specific configurations (dev/staging/prod) A/B testing of different fare structures Dynamic pricing rule adjustments 3. Type Safety Strongly-typed configuration classes Compile-time validation IntelliSense support for configuration 4. Testability Easy to mock configuration in tests Isolated testing of configuration scenarios Consistent test data setup \uD83E\uDDEA Testing Updates Updated all test files to provide configuration mocks: StationServiceTests - Mock station list and geography options FareRuleEngineTests - Mock fare calculation options ZoneBasedFareStrategyTests - Mock zone fare configuration PassengerDiscountStrategyTests - Mock discount configuration Integration Tests - Full configuration setup for end-to-end testing All 54 tests continue to pass after the migration. \uD83D\uDE80 Validation Build Status: ✅ PASSED dotnet build # Result: Build succeeded Test Status: ✅ ALL PASSED dotnet test # Result: total: 54, failed: 0, succeeded: 54, skipped: 0 Application Status: ✅ FUNCTIONAL Application starts successfully Loads configuration from appsettings.json All fare calculation logic works as expected Station data loaded from configuration \uD83D\uDCC8 Impact Summary Configuration Lines: 114 lines of JSON configuration Code Files Modified: 15 files New Configuration Classes: 8 classes Hardcoded Constants Eliminated: 20+ constants Test Compatibility: 100% maintained Functionality: 100% preserved \uD83D\uDD04 Migration Pattern The migration followed a consistent pattern: Extract hardcoded constants to configuration classes Create strongly-typed options classes Inject IOptions<T> into service constructors Replace hardcoded values with configuration property access Register configuration sections in DI container Update tests with configuration mocks Validate functionality preservation This pattern can be reused for future configuration migrations in other projects. \uD83C\uDFAF Next Steps The configuration system is now ready for: Environment-specific overrides (appsettings.Development.json) Azure App Configuration integration Feature flags for experimental fare rules External configuration management systems Dynamic configuration reloading (with IOptionsMonitor<T>) \uD83D\uDCDD Conclusion Successfully transformed a hardcoded application into a flexible, configuration-driven system while maintaining 100% backward compatibility and test coverage. The Metro Fare Calculator is now ready for production deployment with enterprise-grade configuration management."
  },
  "DOCS_MONITORING.html": {
    "href": "DOCS_MONITORING.html",
    "title": "DocFX Documentation Monitoring System | Metro Fare Calculator API Documentation",
    "summary": "DocFX Documentation Monitoring System This system automatically monitors changes in your codebase and documentation files, then rebuilds your DocFX documentation whenever changes are detected. Features \uD83D\uDD04 Automatic Monitoring: Watches source code, documentation files, and configuration changes ⚡ Smart Debouncing: Prevents excessive rebuilds during rapid file changes \uD83C\uDF9B️ Multiple Run Modes: Foreground, daemon, or systemd service \uD83D\uDCCA Comprehensive Logging: Detailed logs of all monitoring and build activities \uD83D\uDE80 Hot Reload Support: Automatically refreshes served documentation \uD83D\uDD0D Dependency Checking: Validates all required tools are installed \uD83C\uDFA8 Colorized Output: Easy-to-read status messages and progress indicators Quick Start 1. Install Dependencies ./install-dependencies.sh This will install: inotify-tools (for file system monitoring) .NET SDK (for building C# projects) DocFX (for generating documentation) 2. Test the Setup ./monitor-docs.sh --check 3. Build Documentation Once ./monitor-docs.sh --build 4. Start Monitoring # Run in foreground (see live updates) ./monitor-docs.sh # Run as background daemon ./monitor-docs.sh --daemon # Stop daemon ./monitor-docs.sh --stop Usage Options Command Line Options ./monitor-docs.sh [OPTIONS] OPTIONS: -h, --help Show help message -d, --daemon Run as daemon (background process) -s, --stop Stop any running monitor daemon -c, --check Check dependencies and configuration -b, --build Build documentation once and exit Examples: ./monitor-docs.sh # Start monitoring (foreground) ./monitor-docs.sh --daemon # Start monitoring as daemon ./monitor-docs.sh --build # Build documentation once ./monitor-docs.sh --stop # Stop daemon Systemd Service (Advanced) For production environments, you can install as a systemd service: # Install service (replace 'username' with your username) sudo cp docs-monitor.service /etc/systemd/system/docs-monitor@.service sudo systemctl daemon-reload # Enable and start service sudo systemctl enable docs-monitor@username.service sudo systemctl start docs-monitor@username.service # Check status sudo systemctl status docs-monitor@username.service # View logs sudo journalctl -u docs-monitor@username.service -f Monitored Files and Directories The system monitors changes in: Directories src/ - Source code files docs/ - Documentation files tests/ - Test files api/ - API documentation files Files docfx.json - DocFX configuration README.md - Main readme file index.md - Index documentation toc.yml - Table of contents *.md - All markdown files File Types Watched *.cs - C# source files *.csproj - C# project files *.md - Markdown files *.yml, *.yaml - YAML files *.json - JSON configuration files Configuration Debounce Settings The monitor uses a 2-second debounce time to prevent excessive rebuilds. You can modify this in monitor-docs.sh: DEBOUNCE_TIME=2 # Wait 2 seconds after last change before rebuilding Exclusions The following paths are automatically excluded from monitoring: .git/, .vs/, .vscode/ - Version control and IDE directories bin/, obj/ - Build output directories _site/ - DocFX output directory TestResults/ - Test output directory *.tmp, *.temp, *.swp, *.swo, *.log - Temporary files Log Files docs-monitor.log - Detailed log of all monitoring activities and build results Console Output - Real-time status updates with colorized messages Log Messages \uD83D\uDE80 Starting monitor \uD83D\uDCDD File change detected \uD83D\uDD28 Building documentation ✅ Build completed successfully ❌ Build failed \uD83D\uDD04 DocFx serve detected (auto-reload) ⏳ Debouncing changes Serving Documentation Local Development Start DocFX serve alongside the monitor: # Terminal 1: Start monitoring ./monitor-docs.sh # Terminal 2: Serve documentation docfx serve _site The documentation will be available at http://localhost:8080 Auto-reload When DocFX serve is running, the monitor detects it and your browser will automatically refresh when documentation is rebuilt. Troubleshooting Common Issues \"inotifywait: command not found\" sudo apt-get install inotify-tools \"docfx: command not found\" dotnet tool install -g docfx export PATH=$PATH:$HOME/.dotnet/tools \"dotnet: command not found\" ./install-dependencies.sh Build failures Check docs-monitor.log for detailed error messages Ensure all C# projects compile: dotnet build Validate DocFX configuration: docfx build docfx.json Permission issues chmod +x *.sh Debugging Check system status: ./monitor-docs.sh --check Test build manually: ./monitor-docs.sh --build View detailed logs: tail -f docs-monitor.log Test file monitoring: # In another terminal, make a test change echo \"test\" >> docs/test.md # Watch for detection in monitor output Advanced Configuration Custom Build Script You can modify build-docs.sh to customize the build process: # Add custom pre-build steps echo \"Running custom pre-build tasks...\" # Add custom post-build steps echo \"Running custom post-build tasks...\" # Example: Copy additional files, run validation, etc. Custom Monitoring Modify the WATCH_DIRS and WATCH_FILES arrays in monitor-docs.sh: WATCH_DIRS=( \"src/\" \"docs/\" \"tests/\" \"api/\" \"custom-dir/\" # Add custom directory ) WATCH_FILES=( \"docfx.json\" \"README.md\" \"custom-config.yml\" # Add custom file ) Performance Considerations Large Codebases: The monitor is efficient but may use more CPU/memory with very large repositories Network Drives: Monitoring files on network drives may be slower Docker: When running in Docker, ensure proper volume mounting for file change detection Security The systemd service runs with restricted permissions: No new privileges Private temporary directories Read-only home directory access Kernel protection enabled Integration CI/CD Integration Add to your CI/CD pipeline: # Example GitHub Actions - name: Build Documentation run: ./monitor-docs.sh --build - name: Deploy Documentation run: | # Deploy _site/ directory to your hosting platform IDE Integration Most IDEs will work seamlessly with the monitor. File changes from: Visual Studio / VS Code JetBrains Rider vim/emacs Any text editor Will be automatically detected and trigger rebuilds. Support If you encounter issues: Check this documentation Review log files Test dependencies with --check Try a manual build with --build Check file permissions on scripts"
  },
  "MONITORING_STATUS.html": {
    "href": "MONITORING_STATUS.html",
    "title": "DocFX Documentation Monitoring System - Status Report | Metro Fare Calculator API Documentation",
    "summary": "DocFX Documentation Monitoring System - Status Report ✅ System Successfully Deployed Date: 2025-06-23 13:16 UTC Status: \uD83D\uDFE2 ACTIVE - Monitoring and auto-updating documentation \uD83D\uDCCA Current Status \uD83D\uDD27 Components Installed ✅ inotify-tools - File system monitoring ✅ .NET SDK 8.0.411 - C# project compilation ✅ DocFX 2.78.3 - Documentation generation \uD83D\uDE80 Services Running ✅ Documentation Monitor Daemon (PID: 4326) Status: Active and monitoring changes Log file: docs-monitor.log Debounce time: 2 seconds \uD83D\uDCC1 Monitored Locations src/ - Source code files (*.cs, *.csproj) docs/ - Documentation files (*.md, *.yml) tests/ - Test files api/ - API documentation Root files: README.md, docfx.json, index.md, toc.yml \uD83D\uDCCB Build Process ✅ C# project compilation working ✅ DocFX documentation generation working ✅ Output generated in _site/ directory \uD83C\uDFAF Automated Workflow File Change Detection: System monitors file changes using inotify Smart Debouncing: Waits 2 seconds after last change to avoid excessive rebuilds Automatic Build: Triggers build-docs.sh script Documentation Generation: Builds C# projects (Release configuration) Generates XML documentation Runs DocFX to create HTML documentation Logging: All activities logged to docs-monitor.log \uD83D\uDEE0️ Available Commands # Check system status ./monitor-docs.sh --check # Build documentation once ./monitor-docs.sh --build # Start monitoring (foreground) ./monitor-docs.sh # Start as daemon (background) ./monitor-docs.sh --daemon # Stop daemon ./monitor-docs.sh --stop # View logs tail -f docs-monitor.log \uD83C\uDF10 Serving Documentation To serve the documentation locally: # Install docfx serve (if needed) docfx serve _site # Or build and serve in one command docfx docfx.json --serve Documentation will be available at: http://localhost:8080 \uD83D\uDCC8 Performance & Features Smart Features \uD83D\uDD04 Auto-reload detection: Detects if docfx serve is running \uD83C\uDFA8 Colorized output: Easy-to-read status messages \uD83D\uDCCA Comprehensive logging: Detailed activity logs ⚡ Debounced rebuilds: Prevents excessive builds during rapid changes \uD83D\uDEE1️ Error handling: Graceful failure handling with detailed error messages Exclusions Automatically ignores changes in: .git/, .vs/, .vscode/ directories bin/, obj/ build output _site/ documentation output TestResults/ test results Temporary files (*.tmp, *.temp, *.swp, etc.) \uD83D\uDD27 Configuration Files Created Files build-docs.sh - Linux-compatible build script monitor-docs.sh - Main monitoring script with full feature set install-dependencies.sh - Dependency installation script docs-monitor.service - Systemd service file DOCS_MONITORING.md - Complete documentation docs-monitor.log - Activity log file Environment Setup .NET SDK installed in /home/ubuntu/.dotnet DocFX tool in /home/ubuntu/.dotnet/tools PATH configured for both locations DOTNET_ROOT environment variable set \uD83C\uDFAF Next Steps The system is now fully operational and will: Continuously monitor your codebase for changes Automatically rebuild documentation when changes are detected Log all activities for monitoring and debugging Handle errors gracefully with detailed error messages Optional Enhancements For production use, consider: Installing as systemd service for system-wide monitoring Setting up web server integration for automatic deployment Configuring CI/CD pipeline integration Adding webhook notifications for build status \uD83C\uDD98 Support & Troubleshooting If issues arise: Check status: ./monitor-docs.sh --check Review logs: tail -f docs-monitor.log Test manual build: ./monitor-docs.sh --build Restart daemon: ./monitor-docs.sh --stop && ./monitor-docs.sh --daemon The system is designed to be robust and self-healing, automatically recovering from most common issues. Status: ✅ OPERATIONAL - Documentation monitoring active and ready!"
  },
  "README.html": {
    "href": "README.html",
    "title": "Metro Fare Calculator | Metro Fare Calculator API Documentation",
    "summary": "Metro Fare Calculator A C# console application for calculating metro/subway fare costs with support for different passenger types, time-based pricing, and zone-based fare calculation. Features Zone-based Fare Calculation: Calculates fares based on the number of zones traveled Passenger Type Discounts: Different pricing for adults, children, seniors, students, and disabled passengers Time-based Pricing: Peak hour surcharges and off-peak discounts Distance Calculation: Uses Haversine formula to calculate distances between stations Configuration-based System: All constants (fares, discounts, stations) stored in appsettings.json Dependency Injection: Modern .NET architecture with proper DI container setup Comprehensive Logging: Structured logging throughout the application Unit & Integration Tests: Full test coverage with mocking and real dependency testing Complete Documentation: XML documentation and DocFX-generated API documentation Documentation This project includes comprehensive documentation generated with DocFX: \uD83D\uDCD6 API Documentation XML Documentation: All public APIs are documented with XML comments Generated Documentation Site: Professional documentation website with DocFX Design Patterns Guide: Detailed explanation of Strategy and State pattern implementations API Reference: Complete interface and model documentation \uD83D\uDEE0️ Building Documentation Prerequisites Install DocFX globally: dotnet tool install -g docfx Generate Documentation # Quick build and serve docfx docfx.json --serve # Or use the provided script powershell -ExecutionPolicy Bypass -File build-docs.ps1 # Manual process dotnet build # Generate XML documentation docfx build docfx.json # Build documentation site docfx serve _site # Serve locally at http://localhost:8080 Documentation Structure Main Site: Generated in _site/ directory API Reference: Auto-generated from XML documentation Articles: Markdown files in docs/ directory Configuration: docfx.json with proper paths configured Architecture The application follows clean architecture principles with: Models: Core data structures (Station, FareRequest, FareResponse, PassengerType) Interfaces: Abstractions for all services (IStationService, IFareCalculationService, IFareRuleEngine) Services: Concrete implementations with business logic Configuration: Strongly-typed configuration classes for all settings Dependency Injection: Proper service registration and lifetime management Configuration All hardcoded constants have been moved to appsettings.json for easy customization: Fare Settings (FareCalculation section) { \"FareCalculation\": { \"Currency\": \"USD\", \"ZoneBasedFares\": { \"1\": 2.50, \"2\": 3.75, \"3\": 5.00 }, \"DistanceBasedFares\": { \"BaseFare\": 1.50, \"PerKilometerRate\": 0.25 }, \"PassengerDiscounts\": { \"Adult\": 0.00, \"Child\": 0.50, \"Senior\": 0.30, \"Student\": 0.20, \"Disabled\": 0.50 }, \"TimeBasedRules\": { \"PeakHours\": { \"Surcharge\": 0.25, \"WeekdayMorningStart\": 7, \"WeekdayMorningEnd\": 9, \"WeekdayEveningStart\": 17, \"WeekdayEveningEnd\": 19 }, \"OffPeakHours\": { \"Discount\": 0.10, \"NightStart\": 22, \"NightEnd\": 6 } }, \"ZoneMapping\": { \"A\": 1, \"B\": 2, \"C\": 3 }, \"Priorities\": { \"ZoneBasedFareStrategy\": 100, \"DistanceBasedFareStrategy\": 50, \"PassengerDiscountStrategy\": 100, \"TimeBasedDiscountStrategy\": 90 } } } Station Data (Stations section) Station coordinates, zones, and names are configurable: { \"Stations\": [ { \"Id\": 1, \"Name\": \"Downtown Central\", \"Zone\": \"A\", \"Latitude\": 40.7128, \"Longitude\": -74.0060 } ] } Geography Settings (Geography section) { \"Geography\": { \"EarthRadiusKilometers\": 6371 } } Configuration Benefits Easy Customization: Modify fares without recompiling Environment-specific Settings: Different configs for dev/prod Dynamic Pricing: Change time-based rules seasonally Station Management: Add/modify stations via configuration Strongly-typed: Compile-time safety with configuration classes Fare Rules Base Fares by Zone Same zone (1 zone): $2.50 Cross one zone (2 zones): $3.75 Cross two zones (3 zones): $5.00 Passenger Discounts Adult: No discount (0%) Child: 50% discount Senior: 30% discount Student: 20% discount Disabled: 50% discount Time-based Pricing Peak Hours (weekdays 7-9 AM and 5-7 PM): 25% surcharge Off-Peak Hours (10 PM - 6 AM): 10% discount Regular Hours: No adjustment Getting Started Prerequisites .NET 8.0 SDK or later IDE (Visual Studio, VS Code, or JetBrains Rider) Installation Clone the repository: git clone <repository-url> cd FareCalculator Restore dependencies: dotnet restore Build the solution: dotnet build Running the Application dotnet run --project src/FareCalculator Follow the interactive prompts to: Select origin and destination stations Choose passenger type Enter travel date/time (or use current time) View calculated fare Sample Stations The application includes 8 predefined stations: Zone A: Downtown Central Uptown North Harbor View Zone B: Eastside Plaza Westwood Terminal University Campus Zone C: Southgate Junction Airport Express Running Tests Unit Tests dotnet test tests/FareCalculator.Tests --filter Category!=Integration Integration Tests dotnet test tests/FareCalculator.Tests --filter Category=Integration All Tests dotnet test Test Coverage The test suite includes: Unit Tests: Mock-based testing of individual services Integration Tests: End-to-end testing with real dependencies Theory Tests: Parameterized tests for multiple scenarios Exception Handling: Error condition testing Project Structure FareCalculator/ ├── src/ │ └── FareCalculator/ │ ├── Configuration/ # Strongly-typed configuration classes │ ├── Interfaces/ # Service abstractions │ ├── Models/ # Data models │ ├── Services/ # Business logic implementations │ ├── States/ # State pattern implementations │ ├── Strategies/ # Strategy pattern implementations │ ├── Program.cs # Application entry point │ ├── appsettings.json # Configuration file │ └── FareCalculator.csproj ├── tests/ │ └── FareCalculator.Tests/ │ ├── Services/ # Unit tests │ ├── Strategies/ # Strategy tests │ ├── Integration/ # Integration tests │ └── FareCalculator.Tests.csproj ├── docs/ # Documentation files ├── _site/ # Generated documentation site ├── docfx.json # DocFX configuration ├── FareCalculator.sln └── README.md Dependencies Main Application Microsoft.Extensions.Hosting (8.0.0) Microsoft.Extensions.DependencyInjection (8.0.0) Microsoft.Extensions.Logging (8.0.0) Microsoft.Extensions.Logging.Console (8.0.0) Microsoft.Extensions.Configuration (8.0.0) Microsoft.Extensions.Options.ConfigurationExtensions (8.0.0) Testing Microsoft.NET.Test.Sdk (17.8.0) xunit (2.6.1) xunit.runner.visualstudio (2.5.1) Moq (4.20.69) Example Usage === Metro Fare Calculator === Available Stations: ================== 1. Downtown Central (Zone A) 2. Uptown North (Zone A) 3. Eastside Plaza (Zone B) 4. Westwood Terminal (Zone B) 5. Southgate Junction (Zone C) 6. Airport Express (Zone C) 7. University Campus (Zone B) 8. Harbor View (Zone A) --- New Fare Calculation --- Enter origin station name or ID: 1 Enter destination station name or ID: Airport Express Select passenger type: 1. Adult 2. Child 3. Senior 4. Student 5. Disabled Enter choice (1-5): 2 Enter travel date and time (YYYY-MM-DD HH:MM) or press Enter for now: 2024-01-15 08:30 === Fare Calculation Result === Fare Amount: $3.13 USD Fare Type: Child - Peak Hours Number of Zones: 3 Distance: 32.18 km Description: Journey from Downtown Central to Airport Express covers 3 zone(s). Base fare: $5.00, Final fare after adjustments: $3.13 =============================== Contributing Fork the repository Create a feature branch Add tests for new functionality Ensure all tests pass Submit a pull request License This project is open source and available under the MIT License. Test change to trigger rebuild"
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "API Reference | Metro Fare Calculator API Documentation",
    "summary": "API Reference Welcome to the Metro Fare Calculator API documentation. This section contains the complete API reference for all public classes, interfaces, and methods. Core Namespaces FareCalculator.Configuration Configuration classes for strongly-typed settings management. Key Classes: FareCalculationOptions - Main fare calculation settings GeographyOptions - Geographical calculation constants StationOptions - Station data configuration FareCalculator.Interfaces Service contracts and abstractions. Key Interfaces: IFareCalculationService - Main fare calculation service IStationService - Station management operations IFareRuleEngine - Business rule processing IFareCalculationStrategy - Strategy pattern for fare calculation IDiscountStrategy - Strategy pattern for discount application IFareCalculationState - State pattern for workflow management FareCalculator.Models Core data structures and entities. Key Classes: Station - Metro station with location and zone information FareRequest - Fare calculation input parameters FareResponse - Fare calculation results PassengerType - Passenger classification enumeration FareCalculator.Services Business logic implementations. Key Classes: FareCalculationService - Main fare calculation implementation StationService - Station management and distance calculations FareRuleEngine - Business rules and fare adjustments FareCalculationStateMachine - State machine orchestration FareCalculator.Strategies Strategy pattern implementations for fare calculation algorithms. Key Classes: ZoneBasedFareStrategy - Zone-based fare calculation DistanceBasedFareStrategy - Distance-based fare calculation PassengerDiscountStrategy - Passenger type discounts TimeBasedDiscountStrategy - Time-based fare adjustments FareCalculator.States State pattern implementations for fare calculation workflow. Key Classes: InitialCalculationState - Request validation and setup BaseFareCalculationState - Base fare calculation DiscountApplicationState - Discount strategy application FinalCalculationState - Final fare calculation and formatting Quick Start Basic Fare Calculation // Inject the service IFareCalculationService fareService; // Create a fare request var request = new FareRequest { Origin = new Station { Id = 1, Name = \"Downtown Central\", Zone = \"A\" }, Destination = new Station { Id = 6, Name = \"Airport Express\", Zone = \"C\" }, PassengerType = PassengerType.Adult, TravelDate = DateTime.Now }; // Calculate fare var response = await fareService.CalculateFareAsync(request); Console.WriteLine($\"Fare: ${response.Amount:F2}\"); Station Management // Inject the service IStationService stationService; // Get station by ID var station = await stationService.GetStationByIdAsync(1); // Get all stations var allStations = await stationService.GetAllStationsAsync(); // Calculate distance between stations var distance = await stationService.CalculateDistanceAsync(origin, destination); Architecture Patterns The API implements several design patterns: Strategy Pattern: Pluggable fare calculation algorithms State Pattern: Workflow-based fare processing Dependency Injection: Loose coupling and testability Options Pattern: Strongly-typed configuration Repository Pattern: Data access abstraction Configuration All services use the .NET Options pattern for configuration: // Register configuration services.Configure<FareCalculationOptions>( configuration.GetSection(\"FareCalculation\")); // Inject into services public class FareCalculationService { public FareCalculationService(IOptions<FareCalculationOptions> options) { _options = options.Value; } } See the Configuration Documentation for complete details. Error Handling All services include comprehensive error handling: ArgumentNullException - For null parameters ArgumentException - For invalid parameter values InvalidOperationException - For invalid state transitions Thread Safety All services are designed to be thread-safe and can be registered as singletons or scoped services in the DI container. Performance The API is optimized for performance: Efficient distance calculations using Haversine formula Caching-friendly design Minimal memory allocations Fast lookup operations Testing The API is fully covered by unit and integration tests. See Test Documentation for details."
  },
  "docs/API-Documentation.html": {
    "href": "docs/API-Documentation.html",
    "title": "API Documentation Guide | Metro Fare Calculator API Documentation",
    "summary": "API Documentation Guide Overview The FareCalculator project generates comprehensive XML documentation that can be used by IDEs, documentation generators, and API tools to provide IntelliSense, parameter hints, and detailed API documentation. XML Documentation Files \uD83D\uDCC1 Generated Files Main Project: src/FareCalculator/bin/Debug/net8.0/FareCalculator.xml (52KB) Test Project: tests/FareCalculator.Tests/bin/Debug/net8.0/FareCalculator.Tests.xml \uD83D\uDD27 Usage in IDEs The XML documentation files are automatically used by: Visual Studio: Provides IntelliSense with parameter descriptions and method summaries VS Code: Shows hover information and parameter hints JetBrains Rider: Enhanced code completion and documentation tooltips API Reference \uD83C\uDFDB️ Core Interfaces IFareCalculationService Main service interface for fare calculations. Task<FareResponse> CalculateFareAsync(FareRequest request); IStationService Station management and distance calculation services. Task<Station?> GetStationByIdAsync(int id); Task<Station?> GetStationByNameAsync(string name); Task<IEnumerable<Station>> GetAllStationsAsync(); Task<double> CalculateDistanceAsync(Station origin, Station destination); IFareCalculationStrategy Strategy pattern interface for fare calculation algorithms. string StrategyName { get; } Task<decimal> CalculateBaseFareAsync(FareRequest request); bool CanHandle(FareRequest request); int Priority { get; } IDiscountStrategy Strategy pattern interface for discount applications. string StrategyName { get; } decimal ApplyDiscount(decimal baseFare, FareRequest request); bool AppliesTo(PassengerType passengerType); int Priority { get; } IFareCalculationState State pattern interface for workflow management. string StateName { get; } Task<FareCalculationContext> ProcessAsync(FareCalculationContext context); bool CanTransitionTo(IFareCalculationState nextState); \uD83D\uDCCA Data Models Station Represents a metro station with location and zone information. public class Station { public int Id { get; set; } public string Name { get; set; } public string Zone { get; set; } public double Latitude { get; set; } public double Longitude { get; set; } } FareRequest Input data for fare calculation requests. public class FareRequest { public Station Origin { get; set; } public Station Destination { get; set; } public PassengerType PassengerType { get; set; } public DateTime TravelDate { get; set; } } FareResponse Output data containing calculated fare information. public class FareResponse { public decimal Amount { get; set; } public string Currency { get; set; } public int NumberOfZones { get; set; } public double Distance { get; set; } public string FareType { get; set; } public string Description { get; set; } } PassengerType Enum defining passenger classifications for discount eligibility. public enum PassengerType { Adult, // No discount Child, // 50% discount Senior, // 30% discount Student, // 20% discount Disabled // 50% discount } \uD83D\uDD04 Workflow States InitialCalculationState Validates request data Initializes calculation context Sets up logging and response object BaseFareCalculationState Selects appropriate fare calculation strategy Calculates base fare amount Determines distance and zone information DiscountApplicationState Applies all applicable discount strategies Tracks discount amounts and audit trail Processes discounts in priority order FinalCalculationState Rounds final fare amount Calculates zone count Generates comprehensive fare description \uD83C\uDFAF Strategy Implementations Fare Calculation Strategies ZoneBasedFareStrategy (Priority: 100) Primary strategy for zone-based calculations Uses zone mapping: 1 zone = $2.50, 2 zones = $3.75, 3+ zones = $5.00 DistanceBasedFareStrategy (Priority: 50) Fallback strategy using GPS coordinates Rate: $0.25 per kilometer Discount Strategies PassengerDiscountStrategy (Priority: 100) Applies passenger type discounts Child/Disabled: 50%, Senior: 30%, Student: 20%, Adult: 0% TimeBasedDiscountStrategy (Priority: 90) Peak hours (7-9 AM, 5-7 PM weekdays): +25% surcharge Off-peak hours (10 PM - 6 AM): -10% discount Documentation Generation Commands \uD83D\uDD28 Build Commands # Build with XML documentation dotnet build # Build specific configuration dotnet build --configuration Release # Verbose build output dotnet build --verbosity detailed \uD83D\uDCD6 Documentation Tools The generated XML files can be used with: DocFX: Microsoft's documentation generation tool Sandcastle: Windows-based documentation generator Swagger/OpenAPI: For API documentation if exposing as web API NDoc: Legacy documentation generator Example Usage Basic Fare Calculation // Create request var request = new FareRequest { Origin = new Station { Id = 1, Name = \"Downtown Central\", Zone = \"A\" }, Destination = new Station { Id = 6, Name = \"Airport Express\", Zone = \"C\" }, PassengerType = PassengerType.Adult, TravelDate = DateTime.Now }; // Calculate fare var response = await fareCalculationService.CalculateFareAsync(request); // Result: $5.00 for 3-zone journey With Discounts var request = new FareRequest { Origin = new Station { Id = 1, Name = \"Downtown Central\", Zone = \"A\" }, Destination = new Station { Id = 6, Name = \"Airport Express\", Zone = \"C\" }, PassengerType = PassengerType.Child, // 50% discount TravelDate = new DateTime(2024, 1, 1, 3, 0, 0) // Off-peak: -10% }; var response = await fareCalculationService.CalculateFareAsync(request); // Result: $2.25 (Base: $5.00 → Child discount: $2.50 → Off-peak: $2.25) Testing Documentation The test project also generates XML documentation covering: Unit Tests: Individual component testing Integration Tests: End-to-end workflow testing Strategy Tests: Pattern implementation testing State Tests: Workflow state testing Test Coverage 54 Total Tests: Comprehensive coverage of all functionality Pattern Testing: Both Strategy and State patterns fully tested Error Handling: Exception scenarios and edge cases covered Business Logic: All fare rules and discount calculations verified"
  },
  "docs/Design-Patterns-Implementation.html": {
    "href": "docs/Design-Patterns-Implementation.html",
    "title": "Design Patterns Implementation Guide | Metro Fare Calculator API Documentation",
    "summary": "Design Patterns Implementation Guide Overview The Metro Fare Calculator has been enhanced with two powerful design patterns: Strategy Pattern: For flexible fare calculation and discount algorithms State Pattern: For managing the fare calculation workflow XML Documentation Generation The project is configured to automatically generate comprehensive XML documentation files during build: \uD83D\uDCCB Configuration Main Project: FareCalculator.xml generated in bin/Debug/net8.0/ Test Project: FareCalculator.Tests.xml generated in test output directory Complete API Documentation: All public classes, methods, and properties documented with XML comments \uD83D\uDEE0 Build Settings <PropertyGroup> <GenerateDocumentationFile>true</GenerateDocumentationFile> <DocumentationFile>bin\\$(Configuration)\\$(TargetFramework)\\$(AssemblyName).xml</DocumentationFile> <NoWarn>$(NoWarn);1591</NoWarn> </PropertyGroup> \uD83D\uDCD6 Documentation Features Comprehensive Coverage: All interfaces, models, services, and states documented Parameter Descriptions: Detailed explanations of method parameters and return values Exception Documentation: All thrown exceptions documented with conditions Design Pattern Explanations: XML comments explain Strategy and State pattern implementations Usage Examples: Code examples and value descriptions for properties Strategy Pattern Implementation \uD83C\uDFAF Purpose The Strategy pattern allows the system to dynamically choose different algorithms for fare calculation and discount application based on runtime conditions. \uD83D\uDCCB Key Components 1. Fare Calculation Strategies (IFareCalculationStrategy) public interface IFareCalculationStrategy { string StrategyName { get; } Task<decimal> CalculateBaseFareAsync(FareRequest request); bool CanHandle(FareRequest request); int Priority { get; } } Implementations: ZoneBasedFareStrategy (Priority: 100) - Primary strategy for zone-based calculation DistanceBasedFareStrategy (Priority: 50) - Fallback strategy using GPS coordinates 2. Discount Strategies (IDiscountStrategy) public interface IDiscountStrategy { string StrategyName { get; } decimal ApplyDiscount(decimal baseFare, FareRequest request); bool AppliesTo(PassengerType passengerType); int Priority { get; } } Implementations: PassengerDiscountStrategy (Priority: 100) - Applies passenger type discounts TimeBasedDiscountStrategy (Priority: 90) - Applies peak/off-peak pricing \uD83D\uDD04 Strategy Selection Process Fare Calculation: System selects the highest priority strategy that can handle the request Discount Application: System applies all applicable discount strategies in priority order ✅ Benefits Extensibility: Easy to add new calculation methods (flat rate, premium zones, etc.) Maintainability: Each strategy is isolated and testable Flexibility: Runtime strategy selection based on request characteristics State Pattern Implementation \uD83C\uDFAF Purpose The State pattern manages the fare calculation workflow as a series of well-defined states, each handling specific responsibilities. \uD83D\uDCCA State Workflow Diagram stateDiagram-v2 [*] --> Initial : Start Calculation Initial --> BaseFareCalculation : Validate Request<br/>Initialize Context BaseFareCalculation --> DiscountApplication : Calculate Base Fare<br/>Select Strategy<br/>Get Distance/Zones DiscountApplication --> FinalCalculation : Apply Discounts<br/>Track Adjustments FinalCalculation --> [*] : Finalize Amount<br/>Generate Description<br/>Complete Response note right of Initial • Validate request data • Initialize context • Set up logging • Prepare response object end note note right of BaseFareCalculation • Select fare strategy by priority • Calculate base fare amount • Calculate distance between stations • Determine zone information end note note right of DiscountApplication • Find applicable discount strategies • Apply discounts in priority order • Track total discount amount • Maintain audit trail end note note right of FinalCalculation • Round final fare amount • Calculate zone count • Generate fare description • Complete response object end note \uD83D\uDCCB State Workflow 1. Initial State (InitialCalculationState) Validates the request Initializes the calculation context Sets up logging and metadata 2. Base Fare Calculation State (BaseFareCalculationState) Selects appropriate fare calculation strategy Calculates base fare amount Collects distance and zone information 3. Discount Application State (DiscountApplicationState) Applies all relevant discount strategies Tracks discount amounts and reasons Maintains audit trail of adjustments 4. Final Calculation State (FinalCalculationState) Rounds final amount Generates fare description Prepares final response object \uD83D\uDD04 State Transition Rules Initial → BaseFareCalculation → DiscountApplication → FinalCalculation Each state validates transitions and maintains context integrity. \uD83D\uDCCA Context Object public class FareCalculationContext { public FareRequest Request { get; set; } public FareResponse Response { get; set; } public decimal CurrentFare { get; set; } public IFareCalculationState CurrentState { get; set; } public Dictionary<string, object> Data { get; set; } public List<string> ProcessingLog { get; set; } } ✅ Benefits Clarity: Each state has a single responsibility Maintainability: Easy to modify individual steps Debuggability: Complete audit trail of processing steps Extensibility: Easy to add new states or modify workflow Dependency Injection Configuration Service Registration // Register strategy pattern implementations services.AddScoped<IFareCalculationStrategy, ZoneBasedFareStrategy>(); services.AddScoped<IFareCalculationStrategy, DistanceBasedFareStrategy>(); services.AddScoped<IDiscountStrategy, PassengerDiscountStrategy>(); services.AddScoped<IDiscountStrategy, TimeBasedDiscountStrategy>(); // Register state pattern implementations services.AddScoped<InitialCalculationState>(); services.AddScoped<BaseFareCalculationState>(); services.AddScoped<DiscountApplicationState>(); services.AddScoped<FinalCalculationState>(); // Register state machine services.AddScoped<IFareCalculationStateMachine, FareCalculationStateMachine>(); Example Execution Flow Input Origin: Airport Express (Zone C) Destination: Harbor View (Zone A) Passenger: Adult Time: 3:38 AM (Off-peak) Processing Log 1. Entering state: Initial - Initialized calculation at 2025-06-23 03:38:39 - Route: Airport Express → Harbor View - Passenger: Adult - Travel Date: 2025-06-23 03:38 2. Entering state: BaseFareCalculation - Selected strategy: Zone-Based Calculation - Zone calculation: 3 zones = $5.00 - Distance: 20.74 km 3. Entering state: DiscountApplication - Found 2 applicable discount strategies - Applied Passenger Type Discount: $5.00 → $5.00 (Adult: 0%) - Applied Time-Based Discount: $5.00 → $4.50 (Off-peak: -10%) 4. Entering state: FinalCalculation - Final fare: $4.50 - Calculation completed at 2025-06-23 03:38:39 Output Fare Amount: $4.50 USD Fare Type: Adult - Off-Peak Hours Description: Journey from Airport Express to Harbor View. Calculated using Zone-Based Calculation strategy, covering 3 zone(s). Base fare: $5.00, Final fare after adjustments: $4.50 Testing Strategy Unit Tests Strategy Tests: Test each strategy implementation independently State Tests: Test individual state processing logic Integration Tests: Test complete workflow scenarios Test Coverage 69 total tests (up from 45) Full coverage of both original and pattern-based implementations Backward compatibility maintained Extending the System Adding New Fare Calculation Strategy public class FlatRateFareStrategy : IFareCalculationStrategy { public string StrategyName => \"Flat Rate\"; public int Priority => 75; public bool CanHandle(FareRequest request) => request.Origin.Zone == \"EXPRESS\"; public Task<decimal> CalculateBaseFareAsync(FareRequest request) => Task.FromResult(3.00m); } Adding New Discount Strategy public class GroupDiscountStrategy : IDiscountStrategy { public string StrategyName => \"Group Discount\"; public int Priority => 80; public bool AppliesTo(PassengerType passengerType) => true; public decimal ApplyDiscount(decimal baseFare, FareRequest request) { // Apply 15% discount for group bookings return request.Data.ContainsKey(\"GroupSize\") && (int)request.Data[\"GroupSize\"] >= 5 ? baseFare * 0.85m : baseFare; } } Adding New Processing State public class ValidationState : IFareCalculationState { public string StateName => \"Validation\"; public Task<FareCalculationContext> ProcessAsync(FareCalculationContext context) { // Validate business rules before calculation ValidateStations(context.Request.Origin, context.Request.Destination); ValidateDateTime(context.Request.TravelDate); return Task.FromResult(context); } public bool CanTransitionTo(IFareCalculationState nextState) => nextState.StateName == \"Initial\"; } Architecture Benefits \uD83C\uDFAF Single Responsibility Principle Each strategy and state has one clear purpose \uD83D\uDD13 Open/Closed Principle Open for extension (new strategies/states) but closed for modification \uD83D\uDD04 Dependency Inversion High-level modules depend on abstractions, not concretions \uD83E\uDDEA Testability Each component can be tested independently with mock dependencies \uD83D\uDCC8 Scalability Easy to add new fare rules, calculation methods, or processing steps This pattern-based architecture makes the fare calculation system highly maintainable, extensible, and testable while preserving all existing functionality."
  },
  "docs/Test-Documentation.html": {
    "href": "docs/Test-Documentation.html",
    "title": "Test Documentation | Metro Fare Calculator API Documentation",
    "summary": "Test Documentation Overview The FareCalculator project includes comprehensive test coverage with 54 test cases across unit tests, integration tests, and strategy/state pattern tests. All tests use xUnit framework with Moq for mocking dependencies. Test Statistics Total Tests: 54 Unit Tests: 45 Integration Tests: 9 Success Rate: 100% (54/54 passing) Test Coverage: Comprehensive coverage of all major components Test Suites 1. StationServiceTests (8 tests) Location: tests/FareCalculator.Tests/Services/StationServiceTests.cs Test Methods: GetStationByIdAsync_ValidId_ReturnsStation GetStationByIdAsync_InvalidId_ReturnsNull GetStationByNameAsync_ValidName_ReturnsStation GetStationByNameAsync_CaseInsensitive_ReturnsStation GetStationByNameAsync_InvalidName_ReturnsNull GetAllStationsAsync_ReturnsAllStations CalculateDistanceAsync_ValidStations_ReturnsDistance CalculateDistanceAsync_SameStation_ReturnsZero 2. FareRuleEngineTests (12 tests) Location: tests/FareCalculator.Tests/Services/FareRuleEngineTests.cs Passenger Discount Tests: Adult: 0% discount Child: 50% discount Senior: 30% discount Student: 20% discount Disabled: 50% discount Time-Based Pricing Tests: Peak hours (weekday 7-9 AM, 5-7 PM): +25% surcharge Off-peak hours (10 PM - 6 AM): -10% discount Regular hours: No adjustment Weekend exclusions 3. ZoneBasedFareStrategyTests (8 tests) Location: tests/FareCalculator.Tests/Strategies/ZoneBasedFareStrategyTests.cs Zone Fare Test Cases: 1 zone: $2.50 2 zones: $3.75 3+ zones: $5.00 4. PassengerDiscountStrategyTests (8 tests) Location: tests/FareCalculator.Tests/Strategies/PassengerDiscountStrategyTests.cs Tests all passenger type discounts and strategy behavior. 5. Integration Tests (9 tests) Location: tests/FareCalculator.Tests/Integration/FareCalculationIntegrationTests.cs End-to-End Scenarios: Same zone adult fare: $2.50 Cross zone child fare with discount Peak hour surcharges Off-peak discounts Combined discount scenarios Running Tests # Run all tests dotnet test # Run with detailed output dotnet test --verbosity normal # Run specific test class dotnet test --filter \"FullyQualifiedName~StationServiceTests\" Test Infrastructure Configuration Mocking: All tests use mock configuration Dependency Injection: Full DI container setup in integration tests Mock Framework: Moq for unit test isolation Theory Tests: Parameterized tests for multiple scenarios Test Execution Running Tests"
  },
  "docs/getting-started.html": {
    "href": "docs/getting-started.html",
    "title": "Getting Started | Metro Fare Calculator API Documentation",
    "summary": "Getting Started"
  },
  "docs/introduction.html": {
    "href": "docs/introduction.html",
    "title": "Introduction | Metro Fare Calculator API Documentation",
    "summary": "Introduction"
  },
  "index.html": {
    "href": "index.html",
    "title": "This is the HOMEPAGE. | Metro Fare Calculator API Documentation",
    "summary": "This is the HOMEPAGE. Refer to Markdown for how to write markdown files. Quick Start Notes: Add images to the images folder if the file is referencing an image. Metro Fare Calculator Documentation Welcome to the comprehensive documentation for the Metro Fare Calculator project - a sophisticated fare calculation system built with modern design patterns and best practices. \uD83D\uDE87 Project Overview The Metro Fare Calculator is a .NET 8 console application that demonstrates the implementation of: Strategy Pattern for flexible fare calculation algorithms State Pattern for managing calculation workflows Dependency Injection for loose coupling and testability Comprehensive Testing with 54 unit and integration tests XML Documentation for complete API coverage \uD83C\uDFAF Key Features Fare Calculation Strategies Zone-Based Calculation: Primary strategy using metro zone system Distance-Based Calculation: Fallback strategy using GPS coordinates Priority-Based Selection: Automatic strategy selection based on request characteristics Discount Strategies Passenger Type Discounts: Child (50%), Senior (30%), Student (20%), Disabled (50%) Time-Based Pricing: Peak hour surcharges (+25%) and off-peak discounts (-10%) Configurable Rules: Easy to modify or extend discount policies State Machine Workflow Initial State: Request validation and context initialization Base Fare Calculation: Strategy selection and fare computation Discount Application: Multi-strategy discount processing Final Calculation: Amount rounding and response generation \uD83D\uDCD6 Documentation Sections Design Patterns Implementation Detailed explanation of how Strategy and State patterns are implemented, including: Pattern structure and benefits Implementation examples Workflow diagrams Extension points API Documentation Guide Comprehensive API reference covering: Core interfaces and implementations Data models and enums Usage examples and scenarios XML documentation features \uD83C\uDFD7️ Architecture graph TD A[FareRequest] --> B[FareCalculationService] B --> C[FareCalculationStateMachine] C --> D[InitialCalculationState] D --> E[BaseFareCalculationState] E --> F[DiscountApplicationState] F --> G[FinalCalculationState] G --> H[FareResponse] E --> I[IFareCalculationStrategy] I --> J[ZoneBasedFareStrategy] I --> K[DistanceBasedFareStrategy] F --> L[IDiscountStrategy] L --> M[PassengerDiscountStrategy] L --> N[TimeBasedDiscountStrategy] \uD83D\uDE80 Quick Start // Create a fare request var request = new FareRequest { Origin = new Station { Id = 1, Name = \"Downtown Central\", Zone = \"A\" }, Destination = new Station { Id = 6, Name = \"Airport Express\", Zone = \"C\" }, PassengerType = PassengerType.Adult, TravelDate = DateTime.Now }; // Calculate the fare var response = await fareCalculationService.CalculateFareAsync(request); // Result: $5.00 for 3-zone adult journey Console.WriteLine($\"Fare: {response.Amount:C} {response.Currency}\"); \uD83E\uDDEA Testing The project includes comprehensive testing with: 54 Total Tests covering all functionality Unit Tests for individual components Integration Tests for end-to-end workflows Pattern Tests for Strategy and State implementations Error Handling Tests for edge cases and exceptions \uD83D\uDEE0️ Build and Documentation Building the Project dotnet build dotnet test Generating Documentation # Install DocFX (if not already installed) dotnet tool install -g docfx # Generate documentation site docfx docfx.json --serve The documentation will be available at http://localhost:8080 \uD83D\uDCCB API Reference Browse the complete API Reference for detailed information about: Public interfaces and their implementations Data models and their properties Service classes and their methods Exception types and conditions \uD83E\uDD1D Contributing When extending the system: Add New Strategies: Implement IFareCalculationStrategy or IDiscountStrategy Extend Workflow: Add new states implementing IFareCalculationState Update Tests: Ensure comprehensive test coverage for new features Document Changes: Update XML comments and markdown documentation This documentation is automatically generated from XML documentation comments and Markdown files. For the latest information, please refer to the source code and inline documentation."
  }
}